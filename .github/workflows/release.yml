name: Build and Release

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

jobs:
  build-and-release:
    runs-on: windows-latest
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Install dependencies
        run: bun install

      - name: Get current version
        id: current_version
        run: |
          $version = (Get-Content package.json | ConvertFrom-Json).version
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "Current version: $version"

      - name: Bump version
        id: bump_version
        if: github.event_name == 'workflow_dispatch'
        run: |
          $currentVersion = "${{ steps.current_version.outputs.version }}"
          $parts = $currentVersion -split '\.'
          $major = [int]$parts[0]
          $minor = [int]$parts[1]
          $patch = [int]$parts[2]
          
          $bumpType = "${{ github.event.inputs.version_bump }}"
          
          if ($bumpType -eq "major") {
            $major++
            $minor = 0
            $patch = 0
          } elseif ($bumpType -eq "minor") {
            $minor++
            $patch = 0
          } else {
            $patch++
          }
          
          $newVersion = "$major.$minor.$patch"
          echo "new_version=$newVersion" >> $env:GITHUB_OUTPUT
          echo "New version: $newVersion"

      - name: Determine final version
        id: final_version
        run: |
          $isTag = "${{ startsWith(github.ref, 'refs/tags/') }}"
          $eventName = "${{ github.event_name }}"
          
          if ($isTag -eq "true") {
            # Extract version from tag (remove 'v' prefix if present)
            $tag = "${{ github.ref_name }}"
            $version = $tag -replace '^v', ''
            echo "version=$version" >> $env:GITHUB_OUTPUT
            echo "Using tag version: $version"
          } elseif ($eventName -eq "workflow_dispatch") {
            $version = "${{ steps.bump_version.outputs.new_version }}"
            echo "version=$version" >> $env:GITHUB_OUTPUT
            echo "Using bumped version: $version"
          } else {
            # For push to main, use current version
            $version = "${{ steps.current_version.outputs.version }}"
            echo "version=$version" >> $env:GITHUB_OUTPUT
            echo "Using current version: $version"
          }

      - name: Update versions
        if: github.event_name == 'workflow_dispatch' || (startsWith(github.ref, 'refs/tags/') && github.event_name == 'push')
        run: |
          $version = "${{ steps.final_version.outputs.version }}"
          
          # Update package.json
          $packageJson = Get-Content package.json -Raw | ConvertFrom-Json
          $packageJson.version = $version
          $packageJson | ConvertTo-Json -Depth 10 | Set-Content package.json
          
          # Update tauri.conf.json
          $tauriConf = Get-Content src-tauri/tauri.conf.json -Raw | ConvertFrom-Json
          $tauriConf.version = $version
          $tauriConf | ConvertTo-Json -Depth 10 | Set-Content src-tauri/tauri.conf.json
          
          # Update Cargo.toml
          $cargoToml = Get-Content src-tauri/Cargo.toml -Raw
          $cargoToml = $cargoToml -replace '(?m)^version = ".*"', "version = `"$version`""
          $cargoToml | Set-Content src-tauri/Cargo.toml -NoNewline
          
          echo "Updated all version files to $version"

      - name: Commit version bump
        if: github.event_name == 'workflow_dispatch' && !startsWith(github.ref, 'refs/tags/')
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json src-tauri/tauri.conf.json src-tauri/Cargo.toml
          git diff --staged --quiet || git commit -m "chore: bump version to ${{ steps.final_version.outputs.version }}"
          git push || exit 0

      - name: Import Windows certificate
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          if ($env:WINDOWS_CERTIFICATE -and $env:WINDOWS_CERTIFICATE_PASSWORD) {
            Write-Host "Importing Windows code signing certificate..."
            New-Item -ItemType directory -Path certificate -Force | Out-Null
            Set-Content -Path certificate/tempCert.txt -Value $env:WINDOWS_CERTIFICATE
            certutil -decode certificate/tempCert.txt certificate/certificate.pfx
            Remove-Item -Path certificate/tempCert.txt -Force
            Import-PfxCertificate -FilePath certificate/certificate.pfx -CertStoreLocation Cert:\CurrentUser\My -Password (ConvertTo-SecureString -String $env:WINDOWS_CERTIFICATE_PASSWORD -Force -AsPlainText)
            Remove-Item -Path certificate -Recurse -Force
            Write-Host "Certificate imported successfully"
          } else {
            Write-Host "WINDOWS_CERTIFICATE or WINDOWS_CERTIFICATE_PASSWORD secret not set, skipping code signing"
            Write-Host "Note: Code signing is optional. Your app will still build without it."
          }

      - name: Build Vite project
        run: bun run build

      - name: Build Tauri project
        run: bun run tauri:build
        env:
          # Tauri v2 signing (if using Tauri's signing method)
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
          # Windows code signing (if using standard Windows signing)
          # Certificate should already be imported in the previous step

      - name: Find MSI installer
        id: find_msi
        run: |
          $msiFile = Get-ChildItem -Path "src-tauri\target\release\bundle\msi" -Filter "*.msi" -Recurse | Select-Object -First 1
          if ($msiFile) {
            $msiPath = $msiFile.FullName
            $msiName = $msiFile.Name
            echo "msi_path=$msiPath" >> $env:GITHUB_OUTPUT
            echo "msi_name=$msiName" >> $env:GITHUB_OUTPUT
            echo "Found MSI: $msiPath"
          } else {
            Write-Error "MSI file not found"
            exit 1
          }

      - name: Generate release notes
        id: release_notes
        if: github.event_name == 'workflow_dispatch' || (startsWith(github.ref, 'refs/tags/') && github.event_name == 'push')
        run: |
          $version = "${{ steps.final_version.outputs.version }}"
          $repo = "${{ github.repository }}"
          
          # Try to get previous tag
          $previousTag = git describe --tags --abbrev=0 HEAD^ 2>$null
          
          $body = @"
          ## Release v$version
          
          ### Installation
          Download and run the MSI installer below to install CtrlAltElite.
          
          ### Changes
          "@
          
          if ($previousTag) {
            $body += "See the [changelog](https://github.com/$repo/compare/$previousTag...v$version) for details."
          } else {
            $body += "Initial release or see commit history for changes."
          }
          
          $body | Out-File -FilePath release_notes.md -Encoding utf8
          echo "Generated release notes"

      - name: Create GitHub Release
        if: github.event_name == 'workflow_dispatch' || (startsWith(github.ref, 'refs/tags/') && github.event_name == 'push')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.final_version.outputs.version }}
          name: Release v${{ steps.final_version.outputs.version }}
          body_path: release_notes.md
          files: ${{ steps.find_msi.outputs.msi_path }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push tag
        if: github.event_name == 'workflow_dispatch' && !startsWith(github.ref, 'refs/tags/')
        run: |
          $version = "${{ steps.final_version.outputs.version }}"
          $tag = "v$version"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a "$tag" -m "Release $tag"
          git push origin "$tag" || exit 0
